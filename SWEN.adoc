= SWEN Zusammenfassung
Joël Plambeck <plambjoe@students.zhaw.ch>
0.1,
:toc:
:sectnums:
:sectnumlevels: 3 % sets numbering of header up to level 5
:icons: font
:imagesdir: img

== Software Engineering

Software Engineering beschäftigt sich mit der Herstellung oder Entwicklung von Software, der Organisation und Modellierung der zugehörigen Datenstrukturen und dem Betrieb von Softwaresystemen

|===

| Kernprozesse | Unterstützungsprozesse
a| 
* Anforderungsanalyse (engl. requirementsengineering)
* Softwarearchitektur und Design (engl. softwarearchitectureand design)
* Implementierung (engl. softwareconstruction)
* Softwaretest (engl. softwaretesting)
* Softwareverteilung (engl. softwaredeployment)
* Softwareeinführung (engl. softwarerollout)
* Wartung/Pflege (engl. softwaremaintenance)

a| 
* Projektmanagement (engl. projectmanagement)
* Konfigurationsmanagement (engl. configurationmanagement)
* Qualitätsmanagement (engl. qualitymanagment)
* Risikomanagement (engl. riskmanagement)

|===

=== Iterativ-inkrementell Entwicklungsprozess 

image::http://upload.wikimedia.org/wikipedia/commons/a/ac/Iterative_development_model_V2.jpg[Iteratives Modell, 300, float="right"]

Software wird in mehreren geplanten und kontrolliert durchgeführten Iterationsschritten stückweise (inkrementell) entwickelt.

Ziel und Gelände sind am Anfang unklar: Lenkwaffe.


|===
| Vorteile | Nachteile

a|
* Flexibles Modell bei unklaren Anforderungen/Zielen.
* Gutes Risikomanagement (Mitarbeiter und Technologie).
* Frühe Einsetzbarkeit der Software und Feedback

a| 
* Detaillierte «upfront» Planbarkeit hat Grenzen (Funktionalität, Zeit und Kosten).
* Braucht eine Involvierung und Steuerung durch den Kunden über die ganze Projektdauer

|===

[horizontal]
Definierte Prozesskontrolle:: für einfache und völlig planbare Problemstellungen
Empirische Prozesskontrolle (Agil):: für komplexe, chaotische Problemstellungen (unbekannt, stetig ändernd)

=== Modelle 

Modelle helfen ein Gebilde zu verstehen und kommunizieren. Es hilft as Gebilde zu gestalten, bewerten und kritisieren

=== UML

[horizontal]
Sketch:: informelle und unvollständige Diagramme (von Hand)
Blueprint:: detaillierte Analyse- und Design-Diagramme für Code
Programming-Laguage:: Komplete, ausführbare Spezifikationeines Software-Systems in UML

== Anforderungsanalyse

* Usability
** Deutsch: Gebrauchstauglichkeit
* User Experience
** = Usability + Desirability
* Customer Experience
** = Usability + Desirability + Brand experience

=== Usability Engineering
Ziel: Software entwickeln, welche 3 Anforderungen erfüllt
|===
|Effektivität |Effizienz |Zufriedenheit

|Alle Aufgaben können vollständig erfüllt werden

|Die Aufgabe kann mit angemessenem Aufwand erledigen werden (Mental, Physisch, Zeit)

|Mit dem System/Interaktion ist der Benutzer erfreut

|===

=== Usability Anforderungen
Anforderungsbereiche bezüglich Usabilty

* Aufgabenangemessenheit
* Lernförderlichkeit
* Individualisierbarkeit
* Erwartungskonformität
* Selbstbeschreibungsfähigkeit
* Steuerbarkeit
* Fehlertoleranz

=== User-Centered Design (UCD)

.User-Centered Design
image::UCD.png[User-Centered Design diagram, 300, float="right"]


==== User & Domain Research

*Wer* sind die User? *Was* sind ihre Ziele/Kontext? *Wie*? 

[horizontal]
Contextual Inquiry:: Experte beobachtet User bei seinem Job
Contextual Interview:: 
* Strukturiert (Mündlicher Fragebogen)
* Semi-strukturiert
* Unstrukturiert (Keine Vorbereitung, nur grobe Ziele)

'''
User-Centered Design Process Artefakte:

.Stakeholder Map
image::Stakeholders.png[Stakeholder Diagram, 300, float="right"]

[horizontal]
Personas:: Fiktive Person, represäntiert bestimmte Benutzergruppe
Usage-Szenarien:: Beschreiben die *aktuelle Situation*
Kontext-Szenarien:: Beschreiben die *zukünftige Situation*
Blueprint:: Geschäftsprozessmodell
Storyboard:: Comic mit Schlüsselszenen, 6-8 Bilder mit 1-2 Sätzen
Interaktionskonzepte:: Beschreibt die Interkation mit dem Benutzer
Wireframes:: UI-Prototypen des Interaktionskonzept

.User & Domain Research
image::UDR.png[User & Domain Research Diagram, 300, float="right"]

Fokusgruppen, Umfragen, Nutzungsauswertung, Desktop Research


==== Requirements Analysis

* Wann, wie und warum interagiert der Benutzer mit dem System
* Was sind die wichtigsten Anforderungen an die Interaktion und das System an Benutzersicht

==== Design & Prototype

* Entwicklung des Interaktionskonzepts 
* Umsetzung des Konzepts mit Interaktionsprototypen

==== Evaluate

* Test des Interaktionskonzepts mit Benutzern & Fachexperten
* Basierend auf den Interaktionsprototypen

=== Geschäftsprozessmodell

=== Funktionale Anforderungen (mit Use-Cases)

=== Use-Cases

[cols="2*a"]
|===
|Ausprägungen | Tests

|
Kurz (Brief UC)::
* Titel + 1 Absatz
* Standardablauf (keine Varianten, Problemfälle)
Informell (Casual UC)::
* Title + informelle Beschreibung (1-3 Absätze)
* Beschreibt auch wichtige Varianten
Vollständig (Fully dressed UC)::
* Titel + alle Schritte und Varianten im Detail
* Inklusive Infos über Vorbereitungen, Erfolgsgarantien etc.
| 
Boss-Test:: Falls ganzer Tag in UC investiert wird sollte Boss zufrieden sein.
EBP-Test (Elementary Business Proc.):: Eine Aufgabe die von einer Person an einem Ort zu einer Zeit ausgeführt wird.
Size-Test:: 
* Mehr als eine einzelne Interaktion
* Meist mehrere Seiten.
|===

.Beispiele
[cols="3*a"]
|===
| Brief Use-Case | Casual Use-Case | Fully-dressed Use-Case

|image:BriefUC.png[Brief Use-Case]
|image:CasualUC.png[Casual Use-Case]
|image:FullyDressedUC.png[Fully-dressed Use-Case]
|===

NOTE: "Kassier erfasst das Produkt. System bestätigt Produkt." anstatt "Kassier tippt die Produkt-ID ein. System zeigt Produktnamen."

==== Use-Case-Diagram
[cols="2*a", width="75", grid="none", frame="none"]
|===
|image:UseCaseDiagramm.png[Use-Case-Diagramm]
|image:UseCaseDiagramm2.png[Use-Case-Diagramm]
|===
=== FURPS+

[cols="2*a", grid="none", frame="none"]
|===
|
Functionality (Funktionalität)::
* Features, Fähigkeiten, Sicherheit
Usabiltiy (Gebrauchstauglichkeit)::
* <<_usability_anforderungen>>
* Accessibility (special needs)
Reliability (Zuverlässigkeit)::
* Fehlerrate, Wiederanlauffähigkeit, Vorhersagbarkeit, Datensicherung
Performance (Performanz)::
* Reaktionszeiten, Durchsatz, Genauigkeit, Verfügbarkeit, Ressourceneinsatz
|
Supportability (Unterstützbarkeit)::
* Anpassungsfähigkeit, Wartbarkeit, I18n, Konfigurierbarkeit

+ (Plus)::
* *Implementation*: HW, OS, Sprachen, Tests, Tools
* *Interface*: Schnittstellen von ext. Systemen, Protokolle
* *Operations*: Betriebliche Aspekte
* *Packaging*: Auslieferung physisch, logisch (Container, Plugin...)
* *Legal*: Lizenzen, rechtl. Rahmenbedingungen
|===

=== Systemsequenzdiagram (SSD)

Formal ein UML Sequenzdiagram. Interaktionen der Akteure mit dem System

[cols="3*a"]
|===
|image:SSD_Grundelemente.png[Grundelemente Systemsequenzdiagram]
|image:SSD_Beispiel.png[Beispiel Systemsequenzdiagram]
|image:SSD.png[Systemsequenzdiagram]
|===

==== Systemoperationen

[cols="65a,35a"]
|===
|
* Jedes Systemereignis wird von einer Systemoperation bheandelt.
* Für jede Systemoperation wird ein Design gemacht, wie es im System verarbeitet wird.
* Für eine Systemoperation kann ein Operation contract erstellt werden.
* Systemoperationen in einem SSD repräsentieren Aufrufe vom UI- auf Applikation-/Domainlayer
* Systemoperationen sollten (im englischen) mit "verbObject" bezeichnet werden: enterItem()
* Absicht betonen, nicht wie es gemacht wird: enterItem() anstatt scan()
|image:SystemOperation.png[Systemoperation]
|===

==== Operation Contract

[cols="75a,25a", grid="none", frame="none"]
|===
|
Wann Operation Contracts?::
* Nur Falls Systemoperation unklar/kompliziert oder Entwicklungs ausgelagert wird.
* Erst gegen Ende der Elaborationsphase, kurz vor Design der Sysmtemoperation
|image:OperationsContract.png[Operations Contract]
|===

== Domänenmodellierung

== Softwarearchitektur und Design

== Implementation, Refactoring und Testing

== Entwurf mit Design Patterns

== Vertiefungen

=== Verteilte Systeme

=== GUI-Architekturen

=== Persistenz

=== Framework Design

